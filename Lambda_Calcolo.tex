\documentclass[a4paper,11pt]{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[italian]{babel}
\usepackage{cleveref}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}
\theoremstyle{definition}
\newtheorem{defn}{Definition}
\newtheorem{notation}{Notation}
\newtheorem{ese}{Example}
\newtheorem{oss}{Observation}

\newcommand{\FF}{\mathcal{F}}
\newcommand{\BB}{\mathcal{B}}
%%%
\title{An implementable definition of $\alpha$-equivalence in
$\lambda$-calculus\\
{\large Functional Programming Project}}
\author{Fabio Brau}

\begin{document}
\maketitle
\tableofcontents
\section{Introduction}


This project's aim is to provide a formal definition of $\alpha$-equivalence
on the $\lambda$-terms without seeing it as a transitive closure of a
relation and without assuming conventions on the name of the variables.


\section{Lambda Terms}
From an intuitive point of view, a $\lambda$-term is a representation of
a mathematical function written as a combination of \textit{variables}. It
is quite surprising to notice that ``a systematic notation for functions is lacking
in ordinary mathematics'' [Curry]. In fact, the meaning of $f(x)$, that is the usual
accepted notation to indicate a function (\textit{Euler Notation}), is not uniquely
determined and has to be deduced from the context. Sometimes, with this
notation, we refer to a function depending on the variable $x$; sometimes we refers to the
evaluation of the function in a value (or in a point, a vector, a matrix, a
set and so on) equal to $x$.

An unambiguous way to indicate that the function $f$ depends on the variable $x$ 
could be the notation: $x\mapsto f(x)$. And, we can use the notation $f(x)$
when we want to evaluate $f$ in the object $x$. The introduction of the
symbol $\lambda$ could be helpful, in a typographic sense, by shortening the
notation $x\mapsto f(x)$ in $\lambda x.f(x)$.

\begin{defn}
  Let be $V=\{v_1,v_2,\dots\}$ an infinite set of \textit{variables}. The
  set of the $\lambda$-terms, indicated with $\Lambda$, is recursively
  defined as follow
  \begin{itemize}
    \item $V\subseteq\Lambda$, i.e., each variable is a $\lambda$-term;
    \item If $M$ is a $\lambda$-term, then $\lambda x.M\in\Lambda$, for any variable
      $x$, is a $\lambda$-term called \textit{abstraction};
    \item If $M,N$ are $\lambda$-terms then $(MN)$ is a new $\lambda$-term
      called \textit{application}.
  \end{itemize}
\end{defn}

It's compulsory to observe that the symbols $M,N,\dots, v_0, v_1,\dots$ have
to be intended as names of $\lambda$-terms. The \textit{assignment} of a name
to a $\lambda$-term, indicated with $=$, only holds and has sense in the metalanguage. 
For example, in the formula $M=\lambda x.x$, the symbol $M$ is just the label 
of the $\lambda$-term $\lambda x.x$.

By assuming that the abstraction and the application are associative on the
left (as operators of $\lambda$-terms in the metalanguage) we can introduce
the following notation.
\begin{notation}
  \label{not:left}
  Let $x,y$ be two variables and $M$ a $\lambda$-term, then the formula
  $\lambda xy.M$ is a shorter notation for $\lambda x.\lambda y. M$ that, by
  the left associative convention, represents uniquely $\lambda x.(\lambda y.M)$.
  Similarly, if $X,Y,Z$ are $\lambda$-terms, then the formula $XYZ$ uniquely
  represents $((XY)Z)$ by the left associative rule.
\end{notation}

\begin{defn}
  We will say that two $\lambda$-terms $M,N$ are \textit{syntactically
  equivalents}, and we will write $M\equiv N$, if each one can be mutually
  translated into the other trough the notation \Cref{not:left}.
\end{defn}
\subsection{Bound and Free Variables}
Let us consider the $\lambda$-expression $M=y(\lambda x.x)$. It is evident that
the two variable $x,y$ has a different meaning in the $\lambda$-term. The variable $x$, that 
appears in $M$ under the scope $\lambda$, is \textit{bound} and is not a constant of the 
$\lambda$-term. In a certain sense, that it will be more clear later, the
variable $x$ can be substituted with another variable without that $M$ loses
her meaning. Differently the variable $y$ is \textit{free} and stores a different information that
characterizes the term $M$. Observe, for example, that the term $M$ could represent the
formula $\int_0^y x\,dx$, in which the variable $x$ is usually called ``silent''.


\begin{defn}
  Given a $\lambda$-term $M$, the set $\FF(M)$ of the \textit{free variables}
  of $M$ is recursively defined as follow:
  \begin{itemize}
    \item If $M=x$, where $x\in V$, then $\FF(M)=\{x\}$;
    \item If $M=\lambda x.M_1$, then $\FF(M)=\FF(M_1)\setminus\{x\}$;
    \item If $M=M_1M_2$, then $\FF(M)=\FF(M_1)\cup\FF(M_2)$.
  \end{itemize}
  Analogously, the set $\BB(M)$ of the \textit{bound variables} of $M$
  is recursively defined as follow:
  \begin{itemize}
    \item If $M=x$, where $x\in V$, then $\BB(M)=\emptyset$;
    \item If $M=\lambda x.M_1$, then $\BB(M) = \BB(M_1)\cup \{x\}$;
    \item If $M=M_1M_2$, then $\BB(M)=\BB(M_1)\cup\BB(M_2)$;
  \end{itemize}
\end{defn}
By induction on the construction of $\Lambda$, it is easy to prove that
the definition above is well-placed.

\begin{oss}
  Observe that, by the definition above, a variable $x$ can be either a free and 
  a bound variable of a $\lambda$-term $M$. For example, the 
  $\lambda$-term $M=x(\lambda x.xx)$ is such that $\FF(M) = \BB(M) = \{x\}$.
\end{oss}

\subsection{Substitution without Capture}
Let us consider a $\lambda$-term $M$ and $x$ a free variable of $M$. In this
section we want to define the \textit{substitution operation} in order to
substitute the variable $x$ with another $\lambda$-term $N$ in $M$.

The following definition was first proposed by [Curry] in order to avoid the
issue of the binding of a free variable.

\begin{defn}[Substitution]
  \label{def:subs}
  Let $M,N\in\Lambda$, let us define the operation of \textit{substitution}
  that acts by substituting a variable $x$ in $M$ with $N$, returning a new 
  $\lambda$-term $M[x:=N]$. The
  definition is recursive on the construction of $\Lambda$.
  \begin{itemize}
    \item[{Case 1}] If $M$ is a variable:
      \begin{itemize}
        \item If $M=x$, then $M[x:=N]\equiv N$;
        \item If $M=y$ and $y\ne x$, then $M[x:=N]\equiv y$;
      \end{itemize}
    \item[Case 2] If $M=M_1M_2$ is an application:
      \begin{itemize}
        \item $M[x:=N]\equiv (M_1[x:=N])(M_2[x:=N])$; 
      \end{itemize}
    \item[Case 3] If $M$ is an abstraction:
      \begin{itemize}
        \item If $M=\lambda x.M_1$, then $M[x:=N] \equiv M$;
        \item If $M =\lambda y.M_1$ and $x\ne y$, then
          \[
            M[x:=N] \equiv\lambda z.M_1[y:=z][x:=N]
          \]
          where: $z=y$ if $x\not\in\FF(M_1)$ or $y\not\in\FF(N)$; 
          $z$ is choose to be not in $M$ and not in $N$ otherwise;
      \end{itemize}
  \end{itemize}
\end{defn}

The first and the second case are intuitive. Regarding the third case few
more words are required. If $M$ is an abstraction of the form $\lambda
x.M_1$, substituting $x$ with $N$ has no meaning because $x$ is bound.
Differently, if we want to substitute $x$ in a $\lambda$-term of the form
$\lambda y.M_1$ (and $x\ne y)$, then consider the following example. Let
$M=\lambda y.x$ and $N=y$. Observe that $y$ is free in $N$ and is bound $M$,
and if we change $x$ with $N$ without introducing a new variable $z$ we will
obtain $\lambda y.y$ that is not equivalent, in a sense that it will be more
clear later, to the desired result. This phenomena is called \textit{binding}
of a free variable.

\begin{lemma}
  For any $M,N\in\Lambda$, the following statements hold.
  \begin{enumerate}
    \item If $x\not\in\FF(M)$ and $x\not\in\BB(M)$, then $M[x:=N]\equiv M$;
    \item If $y\not\in\FF(M)$ and $y\not\in\BB(M)$, then $M\equiv M[x:=y][y:=x]$;
    \item If $x\in\FF(M)$ and $y\not\in\FF(M)$, then $x\not\in\FF(M[x:=y])$ e
      $y\in\FF(M[x:=y])$;
  \end{enumerate}
  \label{lem:sost}
  \begin{proof}
    Each statement can be proved by (strong) induction on the construction of the
    $\lambda$-terms. The key idea is to observe that $\Lambda =
    \cup_{n=0}^\infty\Lambda_n$ where: $\Lambda_0=V$ and $\Lambda_n$ contains all the
    $\lambda$-terms that can be generated by application or abstraction of $\lambda$-terms 
    in $\Lambda_k$ with $k<n$. After that, by supposing that independently $1,2,3$ hold
    for $\Lambda_k$ with $k<n$, it is easy by applying the \Cref{def:subs}
    to prove that the statement hold also for $\Lambda_n$.
  \end{proof}
\end{lemma}

\section{$\alpha$-equivalenza}
Intuitivamente una $\lambda$-espressione è ottenuta tramite astrazione e/o
applicazione di $\lambda$-espressioni. Due $\lambda$-espressioni si dicono
$\alpha$ equivalenti se possono essere riscritte una nell'altra a meno di
sostituzione di variabili legate. Questa conversione , per quanto sia
facilmente comprensibile a livello intuitivo, nasconde una serie di
complicazioni. La seguente definizione è una riformulazione della definizione formale
fornita da [Curry et al.].


%Sarà utile nella definizione di
%$\alpha$-equivalenza la seguente definizione
%\begin{defn}
%  Sia $M\in\Lambda$, definiamo ricorsivamente l'insieme $Sub(M)$, dei
%  \textit{sottotermini} o \textit{sottoespressioni} di $M$, come segue:
%  \begin{itemize}
%    \item Se $M=x$ è una variabile, allora $Sub(M)=\{x\}$;
%    \item Se $M=\lambda x.M_1$, allora $Sub(M)=\{M\} \cup Sub(M_1)$;
%    \item Se $M=M_1M_2$, allora $Sub(M)=\{M\}\cup Sub(M_1) \cup Sub(M_2)$.
%  \end{itemize}
%\end{defn}


%\begin{defn}[$\alpha$-equivalenza]
%  Sia $M\in\Lambda$. Consideriamo l'insieme di $\lambda$ espressioni 
%  che si ottengono sostituendo a $M$ la variabile legata $x$. La definizione
%  è costruita per casi come segue
%  \begin{itemize}
%    \item Se $M=x$, allora $R_M=\{x\}$;
%    \item Se $M=\lambda x.M_1$, allora $R_M=\left\{ \lambda
%      y.M_1[x:=y]\,:\,y\not\in\FF(M) \right\}$;
%    \item Se $M=M_1M_2$, allora $R_M=\left\{
%      N_1N_2\,:\,N_1\in R_{M_1},\,N_2\in R_{M_2} \right\}$.
%  \end{itemize}
%  Osserviamo che $R_M$ forniscono un ricoprimento di $\lambda$, precisamente
%  \[
%    \bigcup_{M\in\Lambda} R_M = \Lambda.
%  \]
%
%\end{defn}

\begin{defn}[$\alpha$-equivalenza]
  Definiamo la relazione $\equiv_\alpha$ induttivamente simultanemente alla costruzione
  della lambda espressioni.
  Preso $\Lambda_0$ come l'insieme delle $\lambda$-espressioni di rango $0$
  (costituite da una sola variabile, senza astrazioni o applicazioni), definiamo
  \[
    \forall x,y \in \Lambda_0,\quad x\equiv_\alpha y\iff x=y.
  \]
  Osserviamo che $\equiv_\alpha$ è di equivalenza su $\Lambda_0$.
  Consideriamo ora l'insieme delle $\lambda$-espressioni di rango $k>0$
  definito ricorsivamente come $\Lambda_k=\hat \Lambda_k\cup \bar \Lambda_k$,
  dove
  \[
    \begin{aligned}
      \hat \Lambda_k &=\left\{ \lambda
      x.M\,:M\in\Lambda_{k-1}\right\}\\
      \bar \Lambda_k&=\left\{ (MN), (NM)\,:\, M\in\Lambda_{k-1},\,N\in\Lambda_i,\,i<k \right\}
    \end{aligned}
  \]
  Su questo insieme definiamo la relazione $\equiv_\alpha$ come
  \begin{itemize}
    \item Se $M,N\in\hat\Lambda_{k}$, con $M=\lambda x.M_1$ e $N=\lambda y.N_1$
      allora
      \begin{itemize}
        \item Se $x=y$, allora
          \[
            M\equiv_\alpha N \iff M_1\equiv_\alpha N_1
          \]
        \item Se $x\ne y$, allora
          \[
            M\equiv_\alpha N \iff N_1\equiv_\alpha M_1[x:=y]\quad\wedge\quad
            (y\not\in\FF(M_1) \wedge x\not\in\FF(N_1))
          \]
      \end{itemize}
    \item Se $M,N\in\bar\Lambda_k$, con $M=M_1M_2$ e $N=N_1N_2$, allora
      \[
        M\equiv_\alpha N \iff M_1\equiv_\alpha N_1\wedge M_2\equiv_\alpha N_2
      \]
  \end{itemize}
  Per induzione forte e \Cref{lem:sost} si dimostra che $\equiv_\alpha$ è di equivalenza
  su $\Lambda_k$ per ogni $k$. In conclusione, essendo $\Lambda=\cup_k \Lambda_k$, 
  le relazioni di equivalenza si estendono ad una relazione di equivalenza 
  sulle lambda espressioni.
\end{defn}



\begin{lemma}
  La sostituzione è invariante per $\alpha$-equivalenza. Formalmente, se
  $M\equiv_\alpha M'$ e se $N\equiv_\alpha N'$ allora
  \[
    M[x:= N] \equiv_\alpha M'[x:=N']
  \]
\end{lemma}

\section{Equivalenza Semantica}
Possiamo ora definire una prima versione della equivalenza semantica come segue
\begin{defn}[Teoria $\lambda$]
  Teoria del primo ordine sul linguaggio $\Lambda$ con relazione di equivalenza semantica 
  $\dot =$ per cui valgono i seguenti assiomi
  \begin{itemize}
    \item[($\alpha$)] $M\equiv_\alpha N \Rightarrow M \dot = N$;
    \item[($\beta$)] $(\lambda x.M)N \dot = M[x:=N]$;
    \item[$(\xi)$] $M\dot = N \Rightarrow \lambda x.M \dot = \lambda x.N$;
    \item[$(I)$] $\dot = \subseteq \Lambda\times\Lambda$ è di equivalenza;
    \item[$(II)$] $M\dot = N \Rightarrow \quad ZM\dot =ZN \wedge\, MZ\dot
      =NZ$;
  \end{itemize}
\end{defn}

\end{document}
