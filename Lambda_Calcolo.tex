\documentclass[a4paper,11pt]{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[italian]{babel}
\usepackage{cleveref}
\newtheorem{thm}{Teorema}
\newtheorem{lemma}{Lemma}
\theoremstyle{definition}
\newtheorem{defn}{Definizione}
\newtheorem{notazione}{Notazione}
\newtheorem{esempio}{Esempio}
\newtheorem{oss}{Osservazione}

\newcommand{\FF}{\mathcal{F}}
\newcommand{\BB}{\mathcal{B}}
%%%
\title{An implementable definition of $\alpha$-equivalence in
$\lambda$-calculus\\
{\large Functional Programming Project}}
\author{Fabio Brau}

\begin{document}
\maketitle
\tableofcontents
\section{Introduction}


This project's aim is to provide a formal definition of $\alpha$-equivalence
on the $\lambda$-terms without seeing it as a transitive closure of a
relation and without assuming conventions on the name of the variables.


\section{Lambda Terms}
From an intuitive points of view, a $\lambda$-term is a representation of
a mathematical function written as a combination of \textit{variables}. It
is quite surprising to notice that ``a systematic notation for functions is lacking
in ordinary mathematics'' [Curry]. In fact, the meaning of $f(x)$, that is the usual
accepted notation to indicate a function (\textit{Euler Notation}), is not uniquely
determined and has to be deduced from the context. Sometime we refers to the
definition of  a function of the variable $x$; sometimes we refers to the
evaluation of the function in a value (or in a point, a vector, a matrix, a
set and so on) equal to $x$.

An unambiguous way to indicate that the function $f$ depends on the variable $x$ 
could be the notation: $x\mapsto f(x)$. And, we can use the notation $f(x)$
when we intend to evaluate $f$ in the object $x$. The introduction of the
symbol $\lambda$ could help in a typographic sense by shortening the
notations $x\mapsto f(x)$ in $\lambda x.f(x)$.

\begin{defn}
  Let be $V={v_1,v_2,\dots}$ an infinite set of \textit{variables}. The
  set of the $\lambda$-terms, indicated with $\Lambda$, is recursively
  defined as follow
  \begin{itemize}
    \item $V\subseteq\Lambda$, i.e., each variable is a $\lambda$-term;
    \item If $M$ is a $\lambda$-term, then $\lambda x.M\in\Lambda$, for any variable
      $x$, is a $\lambda$-term called \textit{abstraction};
    \item If $M,N$ are $\lambda$-terms then $(MN)$ is a new $\lambda$-term
      called \textit{application}.
  \end{itemize}
\end{defn}

It's compulsory to observe that the symbols $M,N,\dots, v_0, v_1,\dots$ have
to be intended as names of $\lambda$-terms. The \textit{assignment} of a name
to a $\lambda$-term, indicated with $=$, has to be ever intend in the
metalanguage. For example, in the formula $M=\lambda x.x$, the symbol $M$ it
is just the label of the $\lambda$-term $\lambda x.x$.

È evidente che in una lambda espressione il numero di volte in cui appare un
simbolo di parentesi o il simbolo $\lambda$ può essere non trascurabile.
Assumendo che i due operatori del metalinguaggio siano associativi a sinistra
possiamo introdurre la seguente notazione che fornisce una scrittura più concisa.
\begin{notazione}
  \label{not:sinistra}
  Siano $x,y$ variabili e sia $M$ una $\lambda$-espressione, allora la notazione
  $\lambda xy.M$ è una scrittura abbreviata per $\lambda x.\lambda y.M$ che
  per associatività a sinistra rappresenta univocamente $\lambda x.(\lambda y.M)$.
  Analogamente, siano $X,Y,Z$ lambda espressioni, la notazione $XYZ$
  rappresenta univocamente (per associatività a sinistra) $((XY)Z)$.
\end{notazione}

\begin{defn}
  Diremo che due lambda espressioni $M,N$ sono \textit{sintatticamente
  equivalenti}, e
  scriveremo $M\equiv N$, se possono essere mutualmente scritte una
  nell'altra utilizzando la \Cref{not:sinistra}.
\end{defn}
\subsection{Variabili libere e legate}
Consideriamo la $\lambda$-espressione $M=\lambda x.xy$ e sia $z\ne x$. Non sorprende che $M$
sia, in un qualche senso da definire, equivalente a $\lambda z.zy$, anche se le due
$\lambda$-espressioni non sono sintatticamente equivalenti, i.e. $M\not\equiv
\lambda z.zy$. Questo è dovuto al fatto che, intuitivamente, la variabile $x$
appare legata a $\lambda$ nella forma $\lambda x$.
\begin{defn}
  Data una $\lambda$-espressione $M$, l'insieme delle \textit{variabili
  libere} $\FF(M)$ è costruito induttivamente come segue:
  \begin{itemize}
    \item $\FF(x)=\{x\}$;
    \item $\FF(\lambda x.P)=\FF(P)\setminus\{x\}$;
    \item $\FF(PQ)=\FF(P)\cup\FF(Q)$;
  \end{itemize}
  dove $x$ è una qualunque variabile e $P,Q$ sono $\lambda$-espressioni.
  Analogamente, l'insieme delle \textit{variabili legate} $\BB(M)$ è definito
  ricorsivamente sulla costruzione di $M$ come segue:
  \begin{itemize}
    \item $\BB(x)=\emptyset$;
    \item $\BB(\lambda x.P) = \BB(P)\cup \{x\}$;
    \item $\BB(PQ)=\BB(P)\cup\BB(Q)$;
  \end{itemize}
\end{defn}

Osserviamo che può accadere che per una $\lambda$-espressione $M$ vale
$\BB(M)\cap\FF(M)\ne\emptyset$. I seguenti esempi possono essere di
chiarimento.

\begin{esempio}
  La $\lambda$-espressione $x(\lambda x.xx)$ ha una sola variabile libera
  ($x$) e solo una variabile legata ($x$).
\end{esempio}

\begin{defn}
  Definiamo l'insieme dei \textit{combinatori} $\Lambda^0\subseteq\Lambda$ come 
  \begin{equation}
    \Lambda^0 =\left\{ M\in\Lambda\,:\, \FF(M)=\emptyset \right\}.
  \end{equation}
\end{defn}

\subsection{Operatore di Sostituzione}
Consideriamo una $\lambda$-espressione $M$ contente una variabile $x$.
Vogliamo definire formalmente l'operazione di \textit{sostituzione} e cioè l'operazione 
nel metalinguaggio che consiste nel sostituire alla variabile $x$ 
una $\lambda$-espressione $N$.

\begin{defn}[Curry]
  Sia $M,N\in\Lambda$, definiamo l'operatore di \textit{sostituzione senza
  cattura} che sostituisce la variabile $x$ nella $\lambda$-espressione $M$ con la
  $\lambda$-espressione $N$, restituendo una $\lambda$-espressione indicata da
  $M[x:=N]$, in modo ricorsivo sulla costruzione delle $\lambda$-espressioni:
  \begin{itemize}
    \item[{Caso 1}] Se $M$ è una variabile:
      \begin{itemize}
        \item Se $M=x$ allora $M[x:=N]\equiv N$;
        \item Se $M=y\ne x$ allora $M[x:=N]\equiv y$;
      \end{itemize}
    \item[Caso 2] Se $M=M_1M_2$ è una applicazione:
      \begin{itemize}
        \item $M[x:=N]\equiv (M_1[x:=N])(M_2[x:=N])$; 
      \end{itemize}
    \item[Caso 3] Se $M$ è una astrazione:
      \begin{itemize}
        \item Se $M=\lambda x.M_1$ allora $M[x:=N] \equiv M$;
        \item Se $M =\lambda y.M_1$, con $x\ne y$, allora 
          \[
            M[x:=N] \equiv\lambda z.M_1[y:=z][x:=N]
          \]
          dove: $z=y$ se $x\not\in\FF(M_1)$ o
          $y\not\in \FF(N)$; $z$ scelta tale che non compare né in $M$ né in
          $N$ altrimenti;
      \end{itemize}
  \end{itemize}
\end{defn}
I primi due casi sono intuitivi, mentre il terzo è più delicato. Consideriamo
$M=\lambda xy.x$ e $N=y$. Nella sostituzione $M[x:=N]$, la variabile libera 
$y$ presente in $N$ verrebbe catturata, in quanto è presente in $M$ come variabile legata, 
diventando anch'essa legata: Questo fenomeno si chiama \textit{cattura} e rende
necessario introdurre la nuova variabile $z$.

\begin{lemma}
  Valgono le seguenti proposizioni
  \begin{enumerate}
    \item Se $x\in\FF(M)$ e $y\not\in\FF(M)$, allora $M\equiv M[x:=y][y:=x]$;
    \item Se $x\in\FF(M)$ e $y\not\in\FF(M)$, allora $x\not\in\FF(M[x:=y])$ e
      $y\in\FF(M[x:=y])$;
  \end{enumerate}
  \label{lem:sost}
\end{lemma}

\section{$\alpha$-equivalenza}
Intuitivamente una $\lambda$-espressione è ottenuta tramite astrazione e/o
applicazione di $\lambda$-espressioni. Due $\lambda$-espressioni si dicono
$\alpha$ equivalenti se possono essere riscritte una nell'altra a meno di
sostituzione di variabili legate. Questa conversione , per quanto sia
facilmente comprensibile a livello intuitivo, nasconde una serie di
complicazioni. La seguente definizione è una riformulazione della definizione formale
fornita da [Curry et al.].


%Sarà utile nella definizione di
%$\alpha$-equivalenza la seguente definizione
%\begin{defn}
%  Sia $M\in\Lambda$, definiamo ricorsivamente l'insieme $Sub(M)$, dei
%  \textit{sottotermini} o \textit{sottoespressioni} di $M$, come segue:
%  \begin{itemize}
%    \item Se $M=x$ è una variabile, allora $Sub(M)=\{x\}$;
%    \item Se $M=\lambda x.M_1$, allora $Sub(M)=\{M\} \cup Sub(M_1)$;
%    \item Se $M=M_1M_2$, allora $Sub(M)=\{M\}\cup Sub(M_1) \cup Sub(M_2)$.
%  \end{itemize}
%\end{defn}


%\begin{defn}[$\alpha$-equivalenza]
%  Sia $M\in\Lambda$. Consideriamo l'insieme di $\lambda$ espressioni 
%  che si ottengono sostituendo a $M$ la variabile legata $x$. La definizione
%  è costruita per casi come segue
%  \begin{itemize}
%    \item Se $M=x$, allora $R_M=\{x\}$;
%    \item Se $M=\lambda x.M_1$, allora $R_M=\left\{ \lambda
%      y.M_1[x:=y]\,:\,y\not\in\FF(M) \right\}$;
%    \item Se $M=M_1M_2$, allora $R_M=\left\{
%      N_1N_2\,:\,N_1\in R_{M_1},\,N_2\in R_{M_2} \right\}$.
%  \end{itemize}
%  Osserviamo che $R_M$ forniscono un ricoprimento di $\lambda$, precisamente
%  \[
%    \bigcup_{M\in\Lambda} R_M = \Lambda.
%  \]
%
%\end{defn}

\begin{defn}[$\alpha$-equivalenza]
  Definiamo la relazione $\equiv_\alpha$ induttivamente simultanemente alla costruzione
  della lambda espressioni.
  Preso $\Lambda_0$ come l'insieme delle $\lambda$-espressioni di rango $0$
  (costituite da una sola variabile, senza astrazioni o applicazioni), definiamo
  \[
    \forall x,y \in \Lambda_0,\quad x\equiv_\alpha y\iff x=y.
  \]
  Osserviamo che $\equiv_\alpha$ è di equivalenza su $\Lambda_0$.
  Consideriamo ora l'insieme delle $\lambda$-espressioni di rango $k>0$
  definito ricorsivamente come $\Lambda_k=\hat \Lambda_k\cup \bar \Lambda_k$,
  dove
  \[
    \begin{aligned}
      \hat \Lambda_k &=\left\{ \lambda
      x.M\,:M\in\Lambda_{k-1}\right\}\\
      \bar \Lambda_k&=\left\{ (MN), (NM)\,:\, M\in\Lambda_{k-1},\,N\in\Lambda_i,\,i<k \right\}
    \end{aligned}
  \]
  Su questo insieme definiamo la relazione $\equiv_\alpha$ come
  \begin{itemize}
    \item Se $M,N\in\hat\Lambda_{k}$, con $M=\lambda x.M_1$ e $N=\lambda y.N_1$
      allora
      \begin{itemize}
        \item Se $x=y$, allora
          \[
            M\equiv_\alpha N \iff M_1\equiv_\alpha N_1
          \]
        \item Se $x\ne y$, allora
          \[
            M\equiv_\alpha N \iff N_1\equiv_\alpha M_1[x:=y]\quad\wedge\quad
            (y\not\in\FF(M_1) \wedge x\not\in\FF(N_1))
          \]
      \end{itemize}
    \item Se $M,N\in\bar\Lambda_k$, con $M=M_1M_2$ e $N=N_1N_2$, allora
      \[
        M\equiv_\alpha N \iff M_1\equiv_\alpha N_1\wedge M_2\equiv_\alpha N_2
      \]
  \end{itemize}
  Per induzione forte e \Cref{lem:sost} si dimostra che $\equiv_\alpha$ è di equivalenza
  su $\Lambda_k$ per ogni $k$. In conclusione, essendo $\Lambda=\cup_k \Lambda_k$, 
  le relazioni di equivalenza si estendono ad una relazione di equivalenza 
  sulle lambda espressioni.
\end{defn}



\begin{lemma}
  La sostituzione è invariante per $\alpha$-equivalenza. Formalmente, se
  $M\equiv_\alpha M'$ e se $N\equiv_\alpha N'$ allora
  \[
    M[x:= N] \equiv_\alpha M'[x:=N']
  \]
\end{lemma}

\section{Equivalenza Semantica}
Possiamo ora definire una prima versione della equivalenza semantica come segue
\begin{defn}[Teoria $\lambda$]
  Teoria del primo ordine sul linguaggio $\Lambda$ con relazione di equivalenza semantica 
  $\dot =$ per cui valgono i seguenti assiomi
  \begin{itemize}
    \item[($\alpha$)] $M\equiv_\alpha N \Rightarrow M \dot = N$;
    \item[($\beta$)] $(\lambda x.M)N \dot = M[x:=N]$;
    \item[$(\xi)$] $M\dot = N \Rightarrow \lambda x.M \dot = \lambda x.N$;
    \item[$(I)$] $\dot = \subseteq \Lambda\times\Lambda$ è di equivalenza;
    \item[$(II)$] $M\dot = N \Rightarrow \quad ZM\dot =ZN \wedge\, MZ\dot
      =NZ$;
  \end{itemize}
\end{defn}

\end{document}
